#version 150
// The fragment shader takes a color pallete accessed according
//   to the "offset" parameter passed as a uniform; this same
//   parameter represents the height each segment will have
//   by the vertex shader. We can't escape having one draw
//   call per segment; not unless we had ranged instanced
//   drawing available (only GL 4.3/DX11, I believe).

uniform sampler2D palette;
uniform float offset, noisePower, ambient, diffuse;
uniform vec3 lightPosition;

in float offsetV;
in vec3 rawNormal, spacePos, screenPos;
out vec4 outputColor;

vec3 XorShiftRNG(vec3 seed) {
    ivec3 is = ivec3(seed * 1048576.0);

    is.yzx ^= is << 13;
    is.zxy ^= is >> 17;
    is.zyx ^= is << 5;
    
    return vec3((2.0 * fract(vec3(is) / 1048576.0)) - 1.0);
}

const float pi = 3.141592;

float WaveFun(float x, float t, float f, float p) {
    return pow((1.0 + sin(f * t * pi + x)) * 0.5, p);
}

void main() {
    vec3 noise = XorShiftRNG(spacePos);
    
    // The Z pos is heavily skewed by openFrameworks, so we
    //  have to adjust it to sane values instead. Those
    //  constants were tweaked by hand.
    float depth = screenPos.z * 0.001;
    depth = (depth - 0.518) * 100;
    
    // We need the flat normal so we can fix the ugly seams
    //  that appear at the top of the model after lighting
    //  with the normals generated by FingerMesh's code.
    
    vec3 normal = normalize(rawNormal);
    vec3 flatNormal = normalize(cross(dFdx(screenPos), dFdy(screenPos)));
    
    // This instruction essentially picks the smooth normal
    //  wherever it and the flat normal agree in angle
    //  (the sides), but chooses the flat normal (top and
    //  bottom parts) if they disagree beyond a threshold.
    normal = (dot(normal, flatNormal) < 0.9) ? flatNormal : normal;
    normal = normalize(normal);// + noisePower * noise * exp(-depth));
    
    // TODO: add more lights using a uniform array
    float lightDiff = clamp(dot(normal, normalize(lightPosition - screenPos)), 0.0, 1.0);
    
    outputColor.rgb = ambient + texture(palette, vec2((offsetV - 1.0)/3.0, 0.5)).rgb * diffuse * lightDiff;
    outputColor.a = 1.0;
    
}
